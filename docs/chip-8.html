<!-- So that firefox is not in quirks mode -->
<!DOCTYPE html>

<style>
  * {
    background-color: #101010;
    color: #FFFFFF;
    font-size: 18px;
    font-family: monospace;
  }
  table, th, td {
    border: solid 3px #C0C0C0;
    border-collapse: collapse;
  }
  th, td {
    padding: 8px;
  }
  .Op {
    text-align: center;
  }
  table {
    width: 100%;
  }

  .code {
    border: solid 3px #C0C0C0;
    border-collapse: collapse;
    width: fit-content;
    white-space: pre;
    padding: 0.5%;
  }
</style>

You can write comments with the following syntax:
<div class = "code">#This is a comment
</div>
or after an opcode:
<div class = "code">execute 0xE0 # This is the same as "clear"
</div><br>
The language supports labels with the following syntax:<br>
[label_name]: This is for declaring a label, this can be on it's own line or before an opcode<br>
:[label_name] This is how to specify which label to jump to.<br>
Labels can be used as an arguemnt for any opcode that asks for an address(Including the chip-8 variant of the "rjp" opcode)<br>
Example:
<div class = "code">clear: clear
# An example of a "function"
# The only restriction on a label is that it can only consist of letters
# It can have the same name as an opcode
exit:
  exit
  ret
jump :clear
call :exit
</div>
<br>
The language supports decimal, hexadecimal (0xN), octal (0oN) and binary (0bN) format for numbers.<br>
The assembler defaults to hexadecimal unless otherwise specified.<br><br>

This is a list of all the commands that are supported, their assembly like equivalent, what they assemble to and their description<br>
Each opcode and number is 4 bits and represented in hexadecimal (In the following "table")<br>
N: A 4 bit number (NN for 8 bit and NNN for 12 bit addresses)<br>
rx, ry: A register (x and y values are 0-15)
<table>
  <tr>
    <th>Assembly</th>
    <th>Opcode</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>execute NNN</td>
    <td>0NNN</td>
    <td>Execute an instruction at NNN (The interpreter doesn't support this one)</td>
  </tr>
  <tr>
    <td>clear</td>
    <td>00E0</td>
    <td>Clears the screen</td>
  </tr>
  <tr>
    <td>ret</td>
    <td>00EE</td>
    <td>Returns from a subroutine (uses the (presumably) address on the "stack")</td>
  </tr>
  <tr>
    <td>exit</td>
    <td>00FD</td>
    <td>Exit the interpreter (Not chip-8 compatible but supported by the interpreter nonetheless)</td>
  </tr>
  <tr>
    <td>jump NNN</td>
    <td>1NNN</td>
    <td>Jumps to address</td>
  </tr>
  <tr>
    <td>call NNN</td>
    <td>2NNN</td>
    <td>Calls subroutine at address (pushes the current address onto the "stack")</td>
  </tr>
  <tr>
    <td>seq rx NN</td>
    <td>3xNN</td>
    <td>Skip next opcode if rx == NN</td>
  </tr>
  <tr>
    <td>sne rx NN</td>
    <td>4xNN</td>
    <td>Skip next opcode if rx != NN</td>
  </tr>
  <tr>
    <td>seq rx ry</td>
    <td>5xy0</td>
    <td>Skip next opcode if rx == ry</td>
  </tr>
  <tr>
    <td>set rx NN</td>
    <td>6xNN</td>
    <td>Set rx to NN</td>
  </tr>
  <tr>
    <td>add rx NN</td>
    <td>7xNN</td>
    <td>Add NN to rx</td>
  </tr>
  <tr>
    <td>set rx ry</td>
    <td>8xy0</td>
    <td>Set rx to ry</td>
  </tr>
  <tr>
    <td>set rx ry or</td>
    <td>8xy1</td>
    <td>Set rx to rx or ry (bitwise or)</td>
  </tr>
  <tr>
    <td>set rx ry and</td>
    <td>8xy2</td>
    <td>Set rx to rx and ry (bitwise and)</td>
  </tr>
  <tr>
    <td>set rx ry xor</td>
    <td>8xy3</td>
    <td>Set rx to rx xor ry (bitwise xor)</td>
  </tr>
  <tr>
    <td>add rx ry</td>
    <td>8xy4</td>
    <td>Add ry to rx, rF is set to 1 on overflow and 0 otherwise (even if rx and rF is the same register)</td>
  </tr>
  <tr>
    <td>sub rx ry</td>
    <td>8xy5</td>
    <td>Subtract ry from rx, rF is set to 0 on underflow and 1 otherwise (even if rx and rF is the same register)</td>
  </tr>
  <tr>
    <td>rsh rx ry</td>
    <td>8xy6</td>
    <td>Set rx to ry and shift one bit to the right, sets rF to the shifted out bit (even if rx and rF is the same register)</td>
  </tr>
  <tr>
    <td>sub rx ry wtf</td>
    <td>8xy7</td>
    <td>Set rx to ry - rx, rF is set to 1 on underflow and 0 otherwise (even if rx and rF is the same register)</td>
  </tr>
  <tr>
    <td>lsh rx ry</td>
    <td>8xyE</td>
    <td>Set rx to ry and shift one bit to the left, sets rF to the shifted out bit (even if rx and rF is the same register)</td>
  </tr>
  <tr>
    <td>sne rx ry</td>
    <td>9xy0</td>
    <td>Skip next opcode if rx != ry</td>
  </tr>
  <tr>
    <td>sar NNN</td>
    <td>ANNN</td>
    <td>Set the address register to NNN</td>
  </tr>
  <tr>
    <td>regJunp NNN</td>
    <td>BNNN</td>
    <td>Jump to the address NNN + r0 (Incompatible with superchip)</td>
  </tr>
  <tr>
    <td>regJunp rx NN</td>
    <td>BxNN</td>
    <td>Jump to address xNN + rx (what the fuck is this shit?) (Incompatible with chip-8 (thank god))</td>
  </tr>
  <tr>
    <td>rand rx NN</td>
    <td>CxNN</td>
    <td>Set rx to a random value bitwise and-ed with NN</td>
  </tr>
  <tr>
    <td>draw rx ry N</td>
    <td>DxyN</td>
    <td>Draw 8xN pixel sprite at position rX, rY with data starting at the address in the address register (Having N equal to 0 makes the sprite 16 by 16 in the interpreter)  Sets rF to 1 if any set pixels are changed to unset, and 0 otherwise</td>
  </tr>
  <tr>
    <td>spr rx</td>
    <td>Ex9E</td>
    <td>Skip the following instruction if the key corresponding to the hex value currently stored in rX is pressed</td>
  </tr>
  <tr>
    <td>snp rx</td>
    <td>ExA1</td>
    <td>Skip the following instruction if the key corresponding to the hex value currently stored in rX is not pressed</td>
  </tr>
  <tr>
    <td>gdt rx</td>
    <td>Fx07</td>
    <td>Set rx to the delay timer</td>
  </tr>
  <tr>
    <td>wkr rx</td>
    <td>Fx0A</td>
    <td>Wait for a key release and set rX to it's corresponding hex code</td>
  </tr>
  <tr>
    <td>sdt rx</td>
    <td>Fx15</td>
    <td>Set delay timer to rx</td>
  </tr>
  <tr>
    <td>sst rx</td>
    <td>Fx18</td>
    <td>Set sound timer to rx</td>
  </tr>
  <tr>
    <td>aar rx</td>
    <td>Fx1E</td>
    <td>Add rx to the address register</td>
  </tr>
  <tr>
    <td>saf rx</td>
    <td>Fx29</td>
    <td>Set the address register to the 5 line high hex sprite (font) corresponding to the lowest nibble in rX</td>
  </tr>
  <tr>
    <td>saf rx schip</td>
    <td>Fx30</td>
    <td>Set the address register to the 10 line high hex sprite (font) corresponding to the lowest nibble in rX (Incompatible with chip-8)</td>
  </tr>
  <tr>
    <td>bcd rx</td>
    <td>Fx33</td>
    <td>Write the value of rX as BCD value at the address of the address pointer and the next two bytes</td>
  </tr>
  <tr>
    <td>srg rx</td>
    <td>Fx55</td>
    <td>Write the content of r0-rX (including rX) at the memory pointed to by the address register, the address register is incremented by x+1 (x or 0 if ran in schip1.0 or schip1.1 modes respectively)</td>
  </tr>
  <tr>
    <td>lrg rx</td>
    <td>Fx65</td>
    <td>Read the bytes from memory pointed to by I into the registers r0-rX (including rX), the address register is incremented by X+1 (x or 0 if ran in schip1.0 or schip1.1 modes respectively)</td>
  </tr>
  <tr>
    <td>srg rx storage</td>
    <td>Fx75</td>
    <td>Store the content of the registers r0 to rX into flags storage (outside of the addressable ram) (Not compatible with chip-8 but supported by the interpreter nonetheless)</td>
  </tr>
  <tr>
    <td>lrg rx storage</td>
    <td>Fx85</td>
    <td>Load the registers v0 to vX from flags storage (outside the addressable ram) (Not compatible with chip-8 but supported by the interpreter)</td>
  </tr>
  <tr>
    <td>create [values]</td>
    <td>[values]</td>
    <td>
      Embeds values as is into the output binary<br>
      NOTE: Some interpreters might not support "non-aligned" instructions (I haven't encountered this yet)
    </td>
  </tr>
</table> 
